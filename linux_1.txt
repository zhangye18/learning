安装 lrzsz
yum install lrzsz
rz :从本地上传至服务器
sz filename: 从服务器下载文件至本地



linux 内核官网：www.kernel.org
全球服务器分布：www.netcraft.com
VMware:http://www.vmware.com
虚拟机删除工具：VMware_Install_Cleaner
快照
克隆

分区：把大硬盘分为小的逻辑分区
分区类型

主分区：最多只能有4个（等大小的扇区512B  446B 启动信息 64B 进行分区表示 每16B表示一个分区）
扩展分区：
	最多只能有1个
	主分区加扩展分区最多有4个
	不能写入数据，只能包含逻辑分区
逻辑分区

格式化(高级格式化)：写入文件系统
	又称逻辑格式化，它是指根据用户选定的文件系统(如FAT16,FAT32,NTFS,EXT2,EXT3,EXT4等)，在磁盘的特定区域写入特定数据，在分区中划分出一片用于存放文件分配表、目录表等用于文件管理的磁盘空间。
	    硬件                   设备文件名
	IDE硬盘                     /dev/hd[a-d]
	SCSI/SATA/USB硬盘           /dev/sd[a-p]
	光驱                        /dev/cdrom或/dev/hdc
	软盘                        /dev/fd[0-1]
	打印机(25针)                /dev/lp[0-2]
	打印机(USB)                 /dev/usb/lp[0-15]
	鼠标                        /dev/mouse
	
分区设备文件名：给每个分区定义设备文件名
/dev/hda1(IDE硬盘接口)
/dev/sda1(SCSI硬盘接口、SATA硬盘接口)
主分区 [1-4]
逻辑分区从 5 开始

挂载：给每个分区分配挂载点
必须分区
	/(根分区)
	swap分区(交换分区，内存2倍，若是内存大于4G，swap分区等于内存)
推荐分区
	/boot (启动分区，200MB)
	
XShell工具

命令提示符
[root@localhost ~]：
root ： 当前登录用户
localhost 主机名
~ 当前所在目录(家目录)
# 超级用户提示符
  普通用户的提示符是$

命令格式
命令[选项] [参数]
注意：个别命令使用不遵循此格式
      当有多个选项时，可以写在一起
	  简化选项与完整选项
	  -a == --all
	  
查询目录中内容 :ls

ls [选项][文件或目录]
选项：
 -a 显示所有文件，包括隐藏文件
 -l 显示详细信息
 -d 查看目录属性
 -h 人性化显示文件大小
 -i 显示inodes

 -rw-r--r--
 - 文件类型(常见的  -文件  d 目录  l 软链接文件;还有系统特殊文件
 如 块设备文件、字符设备文件、套接字文件、管道文件)
 rw-             r--                   r--
 u所有者         g所属组               o其他人
 
 r读 w写 x执行
 
 建立目录 ：mkdir -p [目录名]
 -p 递归创建
 make a directories
 
 切换所在目录: cd [目录]
 change directory
 
 cd ~  进入当前用户的家目录
 cd    进入当前用户的家目录
 cd -  进入上次目录
 cd .. 进入上一级目录
 cd .  进入当前目录
 
 查询所在目录位置:pwd
 pwd 
 print working directory
 
 删除空目录 :rmdir
 rmdir [目录名]
 remove empty directories
 
 删除文件或目录 :rm
 rm -rf [文件或目录]
 remove
 选项:
	-r 删除目录
	-f 强制
复制命令 :cp
cp [选项][原文件或目录] [目标目录]
copy
选项:
	-r 复制目录
	-p 连带文件属性复制
	-d 若源文件是链接文件，则复制链接属性
	-a 相当于 -pdr
剪切或改名命令: mv
mv [原文件或目录] [目标目录]
move

/ 根目录
根目录下的bin和sbin,usr目录下的bin和sbin 这四个目录都是用来保存系统命令的。
bin目录是普通用户都可以执行的。
sbin 是超级管理员可以执行的

boot 	启动目录
dev  	特殊文件目录
etc  	系统默认配置文件目录
home 	普通用户家目录
root  	超级管理员家目录
lib   	linux函数库目录
mnt   	系统挂载目录
media   挂载目录
tmp		临时目录
proc  sys    不能直接操作，保存的是内存的过载点
sys
var     系统相关文档内容
usr      系统软件资源目录

链接命令 :ln
ln -s [原文件] [目标文件]
link 生成链接文件
选项 -s 创建软链接
注意 创建软链接 原文件必须是绝对路径

软链接特征
1.类似Windows快捷方式
2.软链接拥有自己的I节点和Block块，但是数据块中只保存原文件的文件名和I节点号，并没有实际的文件数据
3.lrwxrwxrwx l 软链接
	软链接文件权限都为rwxrwxrwx
4.修改任意文件，另一个都改变
5. 删除原文件，软链接不能使用


硬链接特征
1.拥有相同的i节点和储存block块，可以看做是同一个文件
2.可通过i节点识别
3.不能跨分区
4.不能针对目录使用

文件搜索命令locate

locate 文件名
在后台数据库中按文件名搜索，搜索速度更快

/var/lib/mlocate
locate命令锁搜索的后台数据库

updatedb
更新数据库

/etc/updatedb.conf 配置文件

PRUNE_BIND_MOUNTS="yes"
开启搜索限制

PRUNEFS=
搜索时，不要搜索文件系统

PRUNENAMES=
搜索时，不搜索的文件类型

PRUNEPATHS=
搜索时，不搜索的路径

搜索命令的命令 whereis
whereis 命令名
搜索命令所在路径及帮助文档所在位置
选项：
	-b:只查找可执行文件
	-m:只查找帮助文件
	
搜索命令的命令which
which 文件名
搜索命令所在路径及别名

PATH环境变量
PATH环境变量:定义的是系统搜索命令的路径
echo $PATH环境变量

find命令
find [搜索范围][搜索条件]
搜索文件

find / -name test.txt
避免大范围搜素，会非常耗费系统资源
find 是在系统当中搜索符合条件的文件名，如果需要匹配，使用通配符匹配，通配符是完全匹配。

find /root iname zhangyubo.txt
不区分大小写

find /root -user root
按照所有者搜索

find /root -nouser
查找没有所有者的文件

find /var/log/ -mtime +10
查找10天前修改的文件

+10  10天前修改的文件
 10  10天当天修改的文件
-10  10天内修改的文件

atime 文件访问时间
ctime 改变文件属性
mtime 修改文件内容

find . -size 25k
查找文件大小是25KB的文件

k/M

-25k 小于25KB的文件
 25k 等于25KB的文件
+25k 大于25KB的文件

find . -inum 262422
查找i节点是262422的文件

find /etc -size +20k -a -size -50k
查找/etc/目录下，大于20KB 并且小于50KB的文件
-a and 逻辑与 两个条件都满足
-o or   逻辑或，两个条件满足一个即可

find /etc -size +20k -a -size -50k -exec ls -lh{}\;
查找/etc/目录下，大于20KB并且小于50KB的文件，并显示详细信息

-exec/-ok命令{}\; 对搜索结果执行操作 
{}和\之间必须要有空格


linux通配符
*  匹配任意内容
?  匹配任意一个字符
[] 匹配任意一个中括号内的字符

搜索字符串命令grep
grep [选项] 字符串 文件名
在文件当中匹配符合条件的字符串
选项:
	-i 忽略大小写
	-v 排除指定字符串

find 命令：在系统当中搜索符合条件的文件名，如果需要匹配，使用通配符匹配，通配符是完全匹配。
 
grep命令：在文件当中搜索符合条件的字符串，如果需要匹配，使用正则表达式进行匹配，正则表达式时包含匹配。

帮助命令man
man 命令
获取指定命令的帮助

/-d 可以查看-d的介绍
n 向下
N 向上

man的级别
1：查看命令的帮助
2：查看可被内核调用的函数的帮助
3：查看函数和函数库的帮助
4：查看特殊文件的帮助(主要是/dev目录下的文件)
5：查看配置文件的帮助
6：查看游戏的帮助
7：查看其它杂项的帮助
8: 查看系统管理员可用命令的帮助
9: 查看和内核相关文件的帮助

查看命令拥有哪个级别的帮助
man -f 命令
==whatis 命令

man -8 ifconfig


man ls
查看ls的帮助

查看和命令相关的所有帮助
man -k 命令
=apropos 命令

如 apropos passwd

选项帮助
命令 --help
获取命令选项的帮助

shell内部命令帮助

help shell内部命令
获取shell内部命令的帮助

如
whereis cd 
确定是否是shell内部命令
help cd
获取内部命令帮助

详细命令帮助info
info 命令
- 回车: 进入子帮助页面(带有*号标记)
-  u:   进入上层页面   
-  n：  进入下一个帮助小节
-  p:   进入上一个帮助小节
-  q:   退出

常用压缩格式:.zip .gz .bz2 .tar.gz .tar.bz2

.zip格式压缩
zip 压缩文件名 源文件
压缩文件

zip -r 压缩文件名 源目录
压缩目录

zip 格式解压缩
unzip 压缩文件
解压缩.zip文件

.gz格式压缩

gzip 源文件
压缩为.gz格式的压缩文件,源文件会消失

gzip -c 源文件 > 压缩文件
压缩为.gz格式，源文件保留
如 gzip -c jp >jp.gz

gzip -r 目录
压缩目录下所有的子文件，但是不能压缩目录

.gz格式解压缩
gzip -d 压缩文件
解压缩文件

gunzip 压缩文件
解压缩文件

.bz2 格式压缩

bzip2 源文件
#压缩为.bz2格式，不保留源文件

bzip2 -k 源文件
压缩之后保留源文件

注意 bzip2命令不能压缩目录

,bz2格式解压缩

bzip2 -d 压缩文件
#解压缩 -k 保留压缩文件

bunzip2 压缩文件
#解压缩 -k保留压缩文件

打包命令tar

tar -cvf 打包文件名 源文件
选项:
	-c: 打包
	-v: 显示过程
	-f: 指定打包后的文件名
	
如： tar -cvf jp.tar jp

解打包命令
tar -xvf 打包文件名
选项:
	-x：解打包
如：tar -xvf jp.tar

.tar.gz压缩格式

其实.tar.gz格式是先打包为.tar格式，再压缩为.gz格式压缩

tar -zcvf 压缩包名.tar.gz 源文件
选项: 
	-z：压缩为.tar.gz格式
	
tar -zxvf 压缩包名.tar.gz
选项: 
	-x：解压缩为.tar.gz格式
	-t :查看压缩的文件
	
.tar.bz2压缩格式


tar -jcvf 压缩包名.tar.bz2 源文件
选项: 
	-z：压缩为.tar.bz2格式
tar -jxvf 压缩包名.tar.bz2
选项: 
	-x：解压缩为.tar.bz2格式

# -C 目录名 解压到指定目录
tar -jxvf jp.tar.bz2 -C /tmp/


shutdown命令
shutdown [选项] 时间
选项：
	-c:  取消前一个关机命令
	-h:  关机
	-r： 重启

其他关机命令
halt
poweroff
init 0
其他重启命令
rebooot
init 6

系统运行级别
0  关机
1  单用户
2  不完全多用户，不喊NFS服务
3  完全多用户
4  未分配
5  图形界面
6  重启

runlevel
#查看系统级别

cat /etc/inittab
#修改系统默认运行级别

logout
#退出登录命令

mount
#查询系统中已经挂载的设备

mount -a
#依据配置文件/etc/fstab的内容，自动挂载


挂载命令格式
mount [-t 文件系统] [-o 特殊选项] 设备文件名 挂载点
选项:
	-t 文件系统：加入文件系统类型来指定挂载的类型，可以ext3\ext4\iso9660等文件系统
	-o 特殊选项：可以指定挂载的额外选项
	
特殊选项

   参数          说明
atime/noatime    更新访问时间/不更新访问时间。访问分区文件时，是否更新文件的访问时间，默认为更新     
async/sync       异步/同步，默认为异步
auto/noauto      自动/手动,mount -a 命令执行时，是否会自动安装/etc/fstab文件内容挂载，默认为自动
defaults         定义默认值，相当于rw,suid,dev,exec,auto,nouser,async这7个选项
exec/noexec      执行/不执行，设定是否允许在文件系统中执行可执行文件，默认是exec允许
remount          重新挂载已经挂载的文件系统，一般用于指定修改特殊权限
rw/ro            读写/只读,文件系统挂载时，是否具有读写权限，默认是rw
suid/nosuid      具有/不具有SUID权限,设定文件系统是否具有SUID和SGID的权限,默认是具有
user/nouser      允许/不允许普通用户挂载,设定文件系统是否允许普通用户挂载,默认是不允许，只有root可以挂载分区
usrquota         写入代表文件系统支持用户磁盘配额，默认不支持
grpquota         写入代表文件系统支持组磁盘配额,默认不支持  
           


如
mount -o remount,noexec /home
#重新挂载/home分区，并使用noexec权限

mount -o remount,exec /home
#改回,否则影响系统启动

挂载光盘

先放入光盘

mkdir /mnt/cdrom/
#建立挂载点

光盘的设备名 /dev/sr0  或者 /dev/cdrom
mount -t iso9660 /dev/sr0 /mnt/cdrom/
== mount /dev/sr0 /mnt/cdrom/  原因系统知道光盘的文件系统类型(iso9660)
#挂载光盘



umount 设备文件名/挂载点
#卸载命令

如: umount /dev/sr0

挂载U盘

fdisk -l
#查看U盘设备文件名

mount -t vfat /dev/sdb1 /mnt/usb/
#挂载U盘
vfat ==windows中的fat32(不支持单个文件超过4G)
注意：Linux默认不支持NTFS文件系统的


查看登录用户信息
w 用户名
命令输出:
	USER:登录的用户名
	TTY：登录终端
	FROM: 从哪个IP地址登录
	LOGIN@：登录时间
	IDLE:用户闲置时间
	JCPU:指的是和该终端连接的所有进程占用的时间。这个时间里并不包括过去的后天作业时间，但却包括当前正在运行的后台作业所占用的时间
	PCPU:是指当前进程所占用的时间
	WHAT:当前正在运行的命令
	
who 用户名
命令输出：
	- 用户名
	- 登录终端
	- 登录时间(登录来源IP地址)

	
查询当前登录和过去登录的用户信息
last
#last命令默认是读取/var/log/wtmp文件数据
命令输出：
	- 用户名
	- 登录终端
	- 登录IP
	- 登录时间
	- 退出时间(在线时间)

查看所有用户的最后一次登录时间	
lastlog
#lastlog命令默认是读取/var/log/lastlog文件数据
命令输出：
	- 用户名
	- 登录终端
	- 登录IP
	- 最后一次登录时间



Shell基础

Shell是一个命令行解释器，它为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序，用户可以用Shell来启动、挂起、停止甚至是编写一些程序。
Shell 还是一个功能相当强大的编程语言，易编写，易调试，灵活性较强。Shell是解释执行的脚本语言，在Shell中可以直接调用Linux系统命令。

Shell分类
Bourne Shell :从1979起Unix就开始使用Bourne Shell,
Bourne Shell 的主文件名为sh

C Shell:C Shell主要在BSD版的Unix系统中使用，其语法和C语言相类似而得名

Bourne家族主要包括sh、ksh、Bash、psh、zsh;
C家族主要包括csh、tcsh

Bash:Bash与sh兼容，现在使用的Linux就是使用Bash作为用户的基本Shell

/etc/shells
# 查看Linux支持的Shell

echo 输出命令
echo [选项][输出内容]
选项：
	-e:支持反斜线控制的字符转换
控制字符     作用
\a            输出警告音 
\b			  退格键，也就是向左删除键
\n			  换行符
\r            回车键
\t			  制表符，也就是Tab键
\v            垂直制表符
\0nnn         按照八进制ASCII码表输出字符。其中0为数字零，nnn是三位八进制数
\xhh          按照十六进制ASCII码表输出字符。其中hh是两位十六进制数

\e[1;开始使用颜色
\e[0m 结束使用颜色
输出颜色
#30m=黑色,31m=红色,32m=绿色,33m=黄色
#34m=蓝色,35m=洋红,36m=青色,37m=白色

脚本执行

1.赋予执行权限，直接运行
chmod 755 hello.sh
./hello.sh

2.通过Bash调用执行脚本
bash hello.sh

alias
#查看系统中所有的命令别名

alias 别名='原命令'
#设定命令别名

vi ~/.bashrc
#写入环境变量配置文件

unalias 别名
#删除别名

命令生效顺序
第一顺位执行用绝对路径或相对路径执行的命令
第二顺位执行别名
第三顺位执行Bash的内部命令
第四顺位执行按照$PATH环境变量定义的目录查找顺序找到的第一个命令

常用快捷键
ctrl+c 强制终止当前命令
ctrl+l 清屏
ctrl+a 光标移动到命令行首
ctrl+e 光标移动到命令行尾
ctrl+u 从光标所在位置删除到行首
ctrl+z 把命令放入后台
ctrl+r 在历史命令中搜索

history [选项] [历史命令保存文件]
选项：
	-c :清空历史命令
	-w : 把缓存中的历史命令写入历史命令保存文件~/.bash_history
历史命令默认会保存1000条，可以在环境变量配置文件/etc/profile中进行修改

历史命令的调用
使用上、下箭头调用以前的历史命令
使用 "!n" 重复执行第n条历史命令
使用 "!!" 重复执行上一条命令
使用 "!字串" 重复执行最后一条以该字串开头的命令

在Bash中，命令与文件补全是非常方便与常用的功能，我们只要在输入命令或文件时，按"Tab"键就会自动进行补全

标准输入输出

设备     设备文件名     文件描述符      类型
键盘	 /dev/stdin         0           标准输入
显示器   /dev/stdout        1           标准输出
显示器   /dev/stderr        2           标准错误输出


输出重定向
类型                      符号                                 作用
标准输出重定向 		   命令 > 文件                          以覆盖的方式，把命令的正确输出输出到指定的文件或设备当中。
标准输出重定向         命令 >> 文件                         以追加的方式，把命令的正确输出输出到指定的文件或设备当中。

标准错误输出重定向 	   错误命令 2>文件(>附近不能有空格)     以覆盖的方式，把命令的错误输出输出到指定的文件或设备当中。
标准错误输出重定向     错误命令 2>>文件(>>附近不能有空格)   以追加的方式，把命令的错误输出输出到指定的文件或设备当中。



正确输出和错误输出同时保存
命令 >文件 2>&1            以覆盖的方式，把正确输出和错误输出都保存到同一个文件当中。
命令 >>文件 2>&1           以追加的方式，把正确输出和错误输出都保存到同一个文件当中。
命令 &>文件                以覆盖的方式，把正确输出和错误输出都保存到同一个文件当中。
命令 &>>文件               以追加的方式，把正确输出和错误输出都保存到同一个文件当中。
命令>>文件1 2>>文件2      把正确的输出追加到文件1中，把错误的输出追加到文件2中

输入重定向
wc [选项][文件名]
选项：
	-c 统计字节数
	-w 统计单词数
	-l 统计行数
	
命令<文件把文件作为命令的输入
命令<<标识符
标识符把标识符之间内容作为命令的输入

1.多命令顺序执行

多命令执行符      格式               作用
;                 命令1;命令2      多个命令顺序执行，命令之间没有任何逻辑联系
&&                命令1&&命令2      逻辑与  当命令1正确执行，则命令2才会执行；当命令1执行不正确，则命令2不会执行 
||                命令1||命令2      逻辑或  当命令1执行不正确，则命令2才会执行；当命令1执行正确，则命令2不会执行 

2.管道符
命令1 | 命令2
#命令1的正确输出作为命令2 的操作对象

netstat -an
#查看所有的网络连接 

通配符   作用
?        匹配一个任意字符
*        匹配0个或任意多个任意字符，也就是可以匹配任何内容
[]       匹配中括号中任意一个字符，例如[abc]代表一定匹配一个字符，或者是a或者是b或者是c
[-]      匹配中括号中任意一个字符，-代表一个范围，例如，[a-z]代表匹配一个小写字母
[^]      逻辑非，表示匹配不是中括号内的一个字符，例如[^0-9]代表匹配一个不是数字的字符



符号     作用
''       单引号，在单引号中所有的特殊符号，如"$"和"`"(反引号)都没有特殊含义
""       双引号，在双引号中特殊符号都没有特殊含义，但是"$"、"`"、"\"是例外，拥有"调用变量的值"、"引用命令"、"转义符"的特殊含义
``       反引号 反引号括起来的内容是系统命令，在Bash中会先执行它.和$()作用一样，不过推荐使用$(),因为反引号非常容易看错。
$()      和反引号作用一样，用来引用系统命令
#         在Shell脚本中，#开头的行表示注释
$         用于调用变量的值
\         转义符，跟在\之后的特殊符号将失去特殊含义，变为普通字符，如\$将输出"$"符号，而不是变量引用



















 


